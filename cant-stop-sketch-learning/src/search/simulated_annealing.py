import os
import pickle
import random
import time
from dsl.base_dsl import *
from evaluation import Evaluation
from os.path import join
from typing import List, Optional, Union, Tuple


class SimulatedAnnealing:
    """Simulated Annealing applied to program synthesis using AST. More detailed information about
    the implementation can be found on the article 'What can we Learn Even From the Weakest?
    Learning Sketches for Programmatic Strategies'.
    """
    def __init__(self, log_file: str, program_file: str) -> None:
        """
        - log_folder is the relative location of where self.log_file will be written.
        - program_folder is the relative location of where self.program_file will be written.
        - log_file is the name of the file where logs of this UCT run will be written.
        - program_file is the name of the file where programs generated by this UCT run will be
          written as plain text.
        - binary_program_file is the name of the file where programs generated by this UCT run will
          be written as binary file.
        - processed is a helper attribute for the mutation step.
        - initial_temperature refers to the temperature schedule.
        - current_temperature refers to the temperature that updates every iteration following the
          temperature schedule.
        - alpha is a hyperparameter the temperature schedule.
        - beta is a hyperparameter for the acceptance function.
        - operations stores all operations allowed by the DSL.
        - numeric_constant_values stores all integers allowed by the DSL.
        - string_constant_values stores all strings allowed by the DSL.
        - variables_list stores two list names that give information about the state of a game.
          'neutrals' stores the positions of the neutral pins and 'actions' stores the available
          actions.
        - variables_scalar store a list name 'marker' that give information about the position of
          the neutral markers. (Defunct attribute, not used - pass an empty list to search).
        - variables_scalar_from_array stores two list names that give information about the weights
          of each column according to the type of the current action. Refer to the article
          "A Generalized Heuristic for Can't Stop".
        - functions_scalars stores methods that extract specific information about the current
          state of a game.
        - eval_function store an evaluation function used to calculate a score of a program.
        - max_mutation_depth is the max depth a program will reach while mutating. If this depth is
          reached, mutation step will only generate terminal nodes.
        - initial_depth_ast auxiliary attribute to count the current depth of the mutation step.
        - slack_time is a "preventive measure" to prevent the algorithm not working properly if max
          set time is too little to start actually running it (classes instantiation, R/W files,
          etc). It is not taken in consideration in the timing showed in the logs.
        """
        self.log_folder = 'logs/'
        self.program_folder = 'programs/'
        self.binary_programs = 'binary_programs/'

        if not os.path.exists(self.log_folder):
            os.makedirs(self.log_folder)

        if not os.path.exists(self.program_folder):
            os.makedirs(self.program_folder)

        if not os.path.exists(self.binary_programs):
            os.makedirs(self.binary_programs)

        self.log_file = 'sa-' + log_file
        self.program_file = 'sa-' + program_file
        self.binary_program_file = self.binary_programs + 'sa-' + program_file + '.pkl'

        self.processed: int = 0
        self.initial_temperature: float = 0.0
        self.current_temperature: float = 0.0
        self.alpha: float = 0.0
        self.beta: float = 0.0

        self.operations: List[Node] = []
        self.numeric_constant_values: List[int] = []
        self.string_constant_values: List[str] = []
        self.variables_list: List[str] = []
        self.variables_scalar: List[str] = []
        self.variables_scalar_from_array: List[str] = []
        self.functions_scalars: List[Node] = []
        self.eval_function: Union[None, Evaluation] = None
        self.max_mutation_depth: int = 4
        self.initial_depth_ast: int = 0
        self.slack_time: float = 600.0
        self.winrate_target: Union[None, float] = 0.0
        self.use_double_program: bool = True

    def mutate_inner_nodes_ast(self, p: Node, index: int) -> bool:
        """Traverse the tree until the "index" node is found, mutate it."""

        self.processed += 1

        if not isinstance(p, Node):
            return False

        for i in range(p.get_number_children()):

            if index == self.processed:
                # Accepted rules for the i-th child
                types = p.accepted_rules(i)

                # Generate instance of a random accepted rule
                child = Node.factory(list(types)[random.randrange(len(types))])

                # Randomly generate the child
                if isinstance(child, Node):
                    self.fill_random_program(child, 0, 4)

                # Replacing previous child with the randomly generated one
                p.replace_child(child, i)
                return True

            mutated = self.mutate_inner_nodes_ast(p.children[i], index)

            if mutated:

                # Fixing the size of all nodes in the AST along the modified branch 
                modified_size = 1
                for j in range(p.get_number_children()):
                    if isinstance(p.children[j], Node):
                        modified_size += p.children[j].get_size()
                    else:
                        modified_size += 1
                p.set_size(modified_size)

                return True

        return False

    def mutate(self, p: Node) -> Node:
        """Uniformly and randomly chooses a node in the AST of p to be mutated. The node chosen is
        also mutated (and all of its children). A new tree is randomly constructed afterwards.
        """

        index = random.randrange(p.get_size())

        # Mutating the root of the AST
        if index == 0:

            if self.use_double_program:
                p = DoubleProgram()
            else:
                initial_types = Node.accepted_rules(0)
                p = Node.factory(list(initial_types)[random.randrange(len(initial_types))])
            self.fill_random_program(p, self.initial_depth_ast, self.max_mutation_depth)

            return p

        self.processed = 0
        self.mutate_inner_nodes_ast(p, index)

        return p

    @staticmethod
    def return_terminal_child(p: Node, types: List[str]) -> Node:
        """Return a terminal node that is a child of program p."""

        terminal_types = []

        for t in types:
            child = p.factory(t)
            terminal_rules = (NumericConstant, StringConstant, VarList, VarScalar,
                              VarScalarFromArray)

            if child.get_number_children() == 0 or isinstance(child, terminal_rules):
                terminal_types.append(child)

        if len(terminal_types) == 0:
            for t in types:
                child = p.factory(t)

                if child.get_number_children() == 1:
                    terminal_types.append(child)

        if len(terminal_types) > 0:
            return terminal_types[random.randrange(len(terminal_types))]

        return p.factory(list(types)[random.randrange(len(types))])

    def fill_random_program(self, p: Node, depth: int, max_depth: int) -> int:
        """Randomly complete p until there are only terminal nodes in the leaves of the AST. If
        depth reaches max_depth, it randomly picks only from terminal rules.
        """

        size = p.get_size()

        for i in range(p.get_number_children()):
            types = p.accepted_rules(i)

            terminal_rules = (
                NumericConstant, StringConstant, VarList,
                VarScalar, VarScalarFromArray
            )

            if isinstance(p, terminal_rules):
                child = list(types)[random.randrange(len(types))]
                p.add_child(child)

                size += 1
            elif depth >= max_depth:
                child = self.return_terminal_child(p, types)
                p.add_child(child)
                child_size = self.fill_random_program(child, depth + 1, max_depth)

                size += child_size
            else:
                child = p.factory(list(types)[random.randrange(len(types))])
                p.add_child(child)
                child_size = self.fill_random_program(child, depth + 1, max_depth)

                size += child_size

        p.set_size(size)
        return size

    def random_program(self) -> Node:
        """Return a completely random generated program allowed by the DSL."""

        if self.use_double_program:
            p = DoubleProgram()
        else:
            initial_types = list(Node.accepted_initial_rules()[0])
            p = Node.factory(initial_types[random.randrange(len(initial_types))])

        self.fill_random_program(p, self.initial_depth_ast, self.max_mutation_depth)

        return p

    def accept_function(self, current_score: float, next_score: float) -> float:
        """Acceptance function of the SA algorithm. Return a value regarding the chance of
        accepting the mutated program.
        """

        return np.exp(self.beta * (next_score - current_score) / self.current_temperature)

    def decrease_temperature(self, i: int) -> None:
        """Update the current temperature according to the following temperature schedule:
        T = T0 / (1+alpha * i) where i is the current SA iteration.
        """

        self.current_temperature = self.initial_temperature / (1 + self.alpha * i)

    def search(self, operations: List[Node], numeric_constant_values: List[int],
               string_constant_values: List[str], variables_scalar: List[str],
               variables_list: List[str], variables_scalar_from_array: List[str],
               functions_scalars: List[Node], eval_function: Evaluation, use_triage: bool,
               use_double_program: bool, initial_temperature: float, alpha: float, beta: float,
               time_limit: float, winrate_target: Optional[Union[None, float]] = None,
               initial_program: Optional[Union[None, Node]] = None) -> Tuple[float, Node]:

        time_start = time.time()

        self.winrate_target = winrate_target
        self.use_double_program = use_double_program

        Node.filter_production_rules(operations,
                                     numeric_constant_values,
                                     string_constant_values,
                                     variables_scalar,
                                     variables_list,
                                     variables_scalar_from_array,
                                     functions_scalars)

        self.max_mutation_depth = 4
        self.initial_depth_ast = 0
        self.initial_temperature = initial_temperature
        self.alpha = alpha
        self.beta = beta
        self.slack_time = 600

        NumericConstant.accepted_types = [set(numeric_constant_values)]
        StringConstant.accepted_types = [set(string_constant_values)]
        VarList.accepted_types = [set(variables_list)]
        VarScalar.accepted_types = [set(variables_scalar)]
        VarScalarFromArray.accepted_types = [set(variables_scalar_from_array)]

        self.operations = operations
        self.numeric_constant_values = numeric_constant_values
        self.string_constant_values = string_constant_values
        self.variables_list = variables_list
        self.variables_scalar_from_array = variables_scalar_from_array
        self.functions_scalars = functions_scalars
        self.eval_function = eval_function

        best_score = 0.0
        best_program = None

        id_log = 1
        number_games_played = 0
        if initial_program is not None:
            current_program = copy.deepcopy(initial_program)
        else:
            current_program = self.random_program()

        while True:
            self.current_temperature = self.initial_temperature

            if use_triage:
                current_score, _, number_matches_played = self.eval_function.eval_triage(
                    current_program, best_score)
            else:
                current_score, _, number_matches_played = self.eval_function.eval(current_program)
            number_games_played += number_matches_played

            iteration_number = 1

            if self.winrate_target is not None and current_score >= self.winrate_target:
                return current_score, current_program

            if best_program is None or current_score > best_score:
                best_score = current_score
                best_program = current_program

                if self.winrate_target is None:
                    with open(join(self.log_folder + self.log_file), 'a') as results_file:
                        str_format = "{:d}, {:f}, {:d}, {:f} \n"
                        results_file.write((str_format.format(id_log, best_score,
                                                              number_games_played,
                                                              time.time() - time_start)))

                    with open(join(self.program_folder + self.program_file), 'a') as results_file:
                        results_file.write(("{:d} \n".format(id_log)))
                        results_file.write(best_program.to_string())
                        results_file.write('\n')

                    id_log += 1
            while self.current_temperature > 1:

                time_end = time.time()

                if time_end - time_start > time_limit - self.slack_time:
                    if self.winrate_target is None:
                        with open(join(self.log_folder + self.log_file), 'a') as results_file:
                            str_format = "{:d}, {:f}, {:d}, {:f} \n"
                            results_file.write((str_format.format(id_log, best_score,
                                                                  number_games_played,
                                                                  time_end - time_start)))

                    with open(self.log_folder + self.log_file + '_best_program',
                              'wb') as file_match:
                        pickle.dump(best_program, file_match)
                    return best_score, best_program

                copy_program = copy.deepcopy(current_program)

                mutation = self.mutate(copy_program)
                if use_triage:
                    next_score, b, n_matches = self.eval_function.eval_triage(mutation, best_score)
                else:
                    next_score, b, n_matches = self.eval_function.eval(mutation)
                if self.winrate_target is not None and next_score >= self.winrate_target:
                    return next_score, mutation

                number_games_played += n_matches

                if best_program is None or next_score > best_score:

                    best_score = next_score
                    best_program = mutation

                    if self.winrate_target is None:
                        with open(join(self.log_folder + self.log_file), 'a') as results_file:
                            str_format = "{:d}, {:f}, {:d}, {:f} \n"
                            results_file.write((str_format.format(id_log, best_score,
                                                                  number_games_played,
                                                                  time_end - time_start)))

                        with open(join(self.program_folder + self.program_file),
                                  'a') as results_file:
                            results_file.write(("{:d} \n".format(id_log)))
                            results_file.write(best_program.to_string())
                            results_file.write('\n')

                        id_log += 1

                prob_accept = min(1.0, self.accept_function(current_score, next_score))

                prob = random.uniform(0, 1)
                if prob < prob_accept:
                    current_program = mutation
                    current_score = next_score

                iteration_number += 1

                self.decrease_temperature(iteration_number)

            if initial_program is not None:
                current_program = copy.deepcopy(initial_program)
            else:
                if best_score == 0:
                    current_program = self.random_program()
                else:
                    current_program = copy.deepcopy(best_program)
